Architecture to cover

o   View Helper (initialize, conditional, binding, validate), ViewHelperService, ViewInitializers
o   Script, jQuery Plugins
o   Controller Base

{toc}
 
h2. Goals

One of the founding modules of Kuali Rice was the Kuali Nervous System.  Designed to help developers create powerful, open-source, enterprise availble applications such as Kuali Financial Systems and Kuali Coeus Research Administration, the Kuali Nervous System provided a framework which relied heavily on configuration, giving developers an easy course to rapid development.  It provided a standard set of tools - lookups, inquiries, documents - based on proven-value Java technologies.  And it provided these capabilities in a way which provided excellent integration with the rest of the growing Kuali Rice stack, especially with Kuali Enterprise Workflow.  Obviously, in its support of KC and the KFS, the Nervous System has proven that it can act as the bedrock of a robust enterprise application.

However, web technology constantly evolves.  Over the past few years, a great deal of progress has been made in the development of strong client-side web technologies, driven by asynchronous web requests (AJAX) and the growth in use of powerful, cross-browser-enabled JavaScript libraries.  Users experiences of the web have changed, and therefore, so have their expectations.  They expect a more interactive, progression-based interface for their applications.

Meanwhile, the needs of applications also evolve.  The initial functional requirements the Kuali Nervous System needed to support were modest and straight-forward.  But the multiple applications build on the KNS have ended up having some complicated requirements which the KNS couldn't solve in a straight forward way.

Given the intense interactivity required by the Kuali Student application, there came a general consensus that the Kuali Nervous System was going to have to embrace new web technologies while providing even better rapid development tools.  Also, the whole concept of a "Nervous System" struck many users as slightly gross.  (And wrong: the nervous system more often seems like the skeleton that holds the application together, rather than the brain.)

And so, the Kuali Rice team embarked on creating a better, more interactive Kuali Nervous System, now rechristened KRAD: the Kuali Rapid Application Development framework.

KRAD's goals are to create a more flexible interface, allowing more richness of interaction, yet still retaining the powerful configuration options which allow developers using the framework the ability to quickly create rapid applications.  As such, KRAD has settled on three major goals: better support for rich user interfaces, more flexibility in the user interface, and improved configuration and tooling for KRAD applications.

h3. Rich UI Support

Over the past few years, web-based user interfaces have taken off.  Many of these technologies have leveraged browser-based JavaScript and Cascading Style Sheets to create impressive effects or to radically increase interactivity by communicating with a web-server in between the normal request/response page cycle.  Because of these huge advances, today's web application users have much higher expectations of interactivity.

KRAD will power up its interactivity offerings by using the JQuery library, currently the de facto standard of rich functionality over the web.  Integrating with JQuery means that KRAD will be able to provide several long-requested interactive features:
- *Lightboxes*  Anyone who has opened an inquiry page in a Kuali application knows that it creates a new tab or even a new window to display, stealing focus away from the originating page.  Users can easily end up with a slew of inquiry tabs to navigate among.  With a Lightbox, an inquiry would display on top of the original page, something like a dialogue box, allowing quick return to the original page and reducing clutter.  Lightboxes can also be used with quick finder lookups on maintenance or transactional documents.
- *Messages*  There are many ways in which rich functionality can be incorporated to inform the user of their progress in an application.  KRAD will support many different kinds of notification schemes to keep the user on top of application progress.  For instance, on forms, there will be much more flexibility than in the KNS to display simple constraint messages on fields and fields can also be preset with sample data - known as a watermark - which is removed when focus is given to the field but hints the user into entering the appropriate data.  Notifications will appear when background processes have completed.  There will be rollover help on fields and time notifications when a given process is completing which help the user understand that the application needs to finish a process.  This wide range of interactive messages will make it easier for users to have a fuller picture of all the application is doing.
- *Progressive Disclosure* No one likes forms which present too many choices, especially when a form presents choices that don't apply to the user's circumstance.  For instance, if a user has to enter a state tax rate on a form, the tax rate field shouldn't show up until the user has chosen a state and the application has determined that the state needs to have a tax rate filled in.  The KNS adopted a principle of "progressive disclosure" - that a form should only show the parts that a user needs currently, and that those parts should appear or disappear based on earlier decisions by the user.  However, this was difficult to implement in the KNS and the fact that a return/request cycle was necessary before the form changed made the experience trying for users as well.  KRAD will support a much more interactive progressive disclosure experience which will make "mini-trips" to the server through AJAX, pulling back needed pieces of the form only when key fields have been entered.
- *Themes* Practically the first customization implementing institutions work on in deployed Kuali applications is skinning the site with their own schools' colors.  Rightly so that institutions should be able to display some pride.  By heavy leveraging of CSS, a requirement simply of making much rich user interface technology work, it will become much easier to redesign a look and feel of a site to match the expectations of your users...or the desire to show off some school pride.

This is just a subset of the way that richer user interface functionality will be integrated into KRAD.  There are many possibilities but one overriding goal: to make it easier for users to interact with applications built on the Kuali platform.

h3. More UI Flexibility

One of the features of the Nervous System users pick up on quickly is the fact that so many screens can be generated purely through configuration.  A business object lookup and inquiry, as well as the screen for maintenance documents, can be generated entirely from an XML file.  Freeing developers from having to concern themselves with the particulars of the HTML generation for these screens makes the user interface of Kuali applications more consistent, to say nothing of the boost to developer productivity it gives.

However, there were other screens which could not be so easily generated.  Transactional documents depended on perhaps several JSP files, supported by hierarchies of tags.  Non-document screens had to have JSPs coded as well.  The KNS provided tags - such as documentPage, tab, htmlControlAttribute, and so on - which eased the development task a bit, but the hard fact was that developers still had to spend much more time coding these pages.

It should therefore be little surprise that one of KRAD's major goals is improving this situation.  If transactional documents and non-document screens could make use of the Rich UI support through configuration, that would make it much easier to develop these incredibly important pieces of functionality.

However, as any KNS developer knows, transactional documents are much more flexible than lookups or maintenance documents.  Maintenance documents are basically stacks of two or four columns apart, perhaps broken up by a standard collection interface.  A transactional document can look like practically anything.  Transactional documents are also the main user interfaces for most Kuali applications.  Therefore, how can the twin goals of developer productivity and user interface flexibility be achieved?

The designers of KRAD take a step back in building user interfaces.  Instead of deferring to the free-form power of a JSP page, isn't it possible to see a page in terms of granular components, grouped together and laid out in a standard fashion?  KRAD will provide precisely this: a series of fields and widgets, all of which are groupable through various means (for example, to create a tab interface already so common in Kuali applications), which can be configured through XML.  They will be laid out on the page by one of a number of layout managers, a concept familiar from the Java Struts user interface framework.

Each of these granular components will, in turn, be backed by a visual rendering provided by the Apache Tiles library.  Specific tiles can be switched out with custom tiles via Spring.

These improvements, which will bring an extraordinary amount of flexibility to the UI rendering system, will be covered in some detail.

h3. Improved Configuration and Tooling

A lot of user feedback about the Kuali Nervous System centered on the repetitive tasks of setting up configuration.  Every business object has an object-relational mapping and an entry in the data dictionary; that entry is made up of field configuration which can get long quickly; and then corresponding Java code to be the actual business object.  Even more pieces are added to this recipe when attempting to put together a document.

KRAD is adopting a series of design principles to alleviate some of the work required for this configuration.  KRAD intends to introduce a series of simple to use tools to generate configuration based on defaults, letting developers focus on tweaking the configuration to match business logic.

KRAD is also simplifying configuration in general.  The idea of "convention over configuration" will mean that standard defaults will be provided for what had to be manually configured before.  These defaults can be overridden but if they fit the needs of the application, no further configuration will be necessary.  This will cut down a huge amount on the "XML push-ups" required by KRAD application developers, but still provide a great deal of flexibility.

h3. Other Goals

KRAD will not only attempt to improve these areas of development, but it will also improve what it already does so well: provide support for lookups, inquiries, and maintenance documents, by making the layout for all of these more flexible.

KRAD's ultimate goal is to provide the kind of framework which will allow more interactive, more complex application functionality.  This has been pushed especially by the requirements of Kuali Student, an application which needs to handle incredibly complex transactions and yet be usable by a large population, many of whom - such as applying students - untrained in its use.  At the same time, KRAD is still going to provide the tight integration with the other components of Kuali Rice, such as Kuali Enterprise Workflow.  Because it is built with such complex requirements in mind, there's little doubt that KRAD is going to be able to support the next generation of open source enterprise applications.

h2. Visual Hierarchy in KRAD applications

One of the most appreciated features of the Kuali Nervous System was that it allowed the set up of the view of certain kinds of documents - Maintenance documents, which maintain rarely changing reference data - inside of the data dictionary for the document.  There was no need to go to JSP: simply configure sections, explain which fields should be on each section, and the KNS generated the view for the document as easily as that.

Of course, the views for maintenance documents did not have too many complexities associated with them.  They showed fields in either two or four columns - depending on if the document was creating a new record or editing an old one - and they supported two levels of collections (collections of collections) on the business object - but no deeper level than that.  Over the years, a great deal of work has been done to make the maintenance document framework more flexible in its view, but the trade off for being so easy to set up was that it couldn't reach the functional complexity that transactional documents allowed.  And of course transactional documents required JSP.

With KRAD, increasing the flexibility of the view so that more of it could be configured became a top feature requirement.

KRAD introduces a concept of a "View" and a hierarchy of pieces which can be added to a view.  A view can represent a whole page.  Inside that page, a number of different groups are arranged - some as tabs, perhaps, others as field sets within other groups or even collections of field sets.  Some of these groups finally were made up of fields, controls, and widgets (controls providing an extra level of interactive functionality by incorporating rich user interface techniques).  All of these - views, groups, fields, controls, and widgets - all are Components of a KRAD render, and therefore all implement the org.kuali.rice.kns.uif.Component interface.

We'll examine each piece of this visual hierarchy in turn.

h3. Containers

A container is simply a Component with a main job of containing other components to render.  Containers may even contain other Containers to render.  Naturally, the task of Containers is fundamental to how to render pages in the application.

h4. Views

As discussed, Components arrange other Components inside a tree.  A Container may hold other Containers, each of which holds other elements like Controls or Fields.

Every tree, though, needs a root.  org.kuali.rice.kns.uif.container.View represents a root Container for all visual Components to be rendered for a document or a screen.  It will be what holds the header and footer as well as any navigation that needs to be available for the document.  On multiple page documents, like the Proposal in Kuali Coeus, all pages will be children of a single view.

The View also manages data processing for the data that is bound to its components.  The View will be configured to know what data needs to be persisted in the session rather than merely the request scope and how form posting should be processed.  It will also hold information on how to conduct validation of models.

Common pieces of functionality will have rendering encapsulated into a common view.  Developers of KNS applications will understand immediately that there will be an InquiryView, a LookupView, as well as MaintenanceDocumentView and TransactionalDocumentView.  Applications can also extend views for common views of their own: for example, Kuali Financial Systems will likely extend TransactionalView to create the AccountingDocumentView.

h4. Groups

The Group is the workhorse of Containers.  It basically acts as the branches of the Component hierarchy tree: it can hold any other kind of Component, including other Groups.  Groups are highly flexible: they can represent an entire page of components, a single tab within that page, or even a set of components within the tab.  Every visual element that KRAD renders is going to be a nesting of groups within groups within groups.

Because they're so common, a number of bean definitions for very common Group types have been set up: Page, Panel, and MenuNavigation to name just a few. [JERRY: SHOULD I NAME ALL OF THESE?]  When designing a page, any set of components that share a layout likely belong in a single Group together.

Despite their ubiquity, there isn't any significant configuration beyond what ContainerBase provides, making the configuration of multiple groups very straightforward.

h5. Collection Groups

A very common practice among rendering frameworks is that all members of a java.util.Collection are rendered using the same set of Components, often within a table.  KRAD naturally associates each member row of the table with a Group - but to accomplish this, a special kind of Group - org.kuali.rice.kns.uif.container.CollectionGroup - was created.  It has a number of extra properties to bind a Collection to the group, most importantly a modelName - the name of the model for each row of the group [JERRY: TRUE THAT?] and a binding path, which is the path to the java.util.Collection from the form [JERRY: TRUE THAT?]

CollectionGroups can also show a set of actions on each row.  An example would be the edit and copy tags that show up in each row of a Lookup.  The CollectionGroup can also render a sequence associated with the Collection, so that each row is numbered "1", "2", etc. which makes it easier for users to differentiate among many rows.  There's also an option to turn header labels on and off for each row.  Finally, a CollectionGroup can have a number of sub-CollectionGroups associated with it, making rendering very flexible indeed.

h5. Navigation Groups

A NavigationGroup is, like a CollectionGroup, a special kind of Group which renders elements used in navigation.  [JAMES!  CONTINUE AS CODE FILLS OUT!]

h4. Layout Managers

Controls, Fields, and Widgets - and even other Groups - can be thrown into a Container.  The question then becomes how KRAD will lay out those controls.

The designers of KRAD decided to apply a venerable idea present in the first version of the Java Advanced Window Toolkit - the concept of Layout Managers.  A LayoutManager is simply a bean which will build the HTML to display Components with a certain algorithm.

For instance, there is the GridLayoutManager.  The GridLayoutManager places sub-Components into a set of side-by-side columns.  For instance, in when a KNS maintenance document copies a business object, it shows four columns side by side: two columns for the original business object's labels and controls and two columns for the copied object's labels and controls.  In KRAD, GridLayoutManager will provide the support for that kind of layout.

KRAD also provides the BoxLayoutManager, which works just like the BoxLayoutManager in the Java AWT.  A BoxLayoutManager is given an aspect - either HORIZONTAL or VERTICAL - and it renders all sub-Components either side by side in the case of HORIZONTAL or on top of each other in the case of VERTICAL.  A simple enough behavior, but nesting Groups with different BoxLayoutManager aspects provides a simple yet flexible way to arrange sub-Components.  The BoxLayoutManager also provides the ability to set the padding in between sub-Components.

[TableLayoutManager; others?  Revisit as coding continues...]
h3. Controls

Anyone who has developed a KNS application knows that property attributes in the data dictionary for a business object or document can be associated with a control - a way to get input for the attribute.  Normal web controls include text fields, text areas, drop down select boxes, and more.  Much like the KNS, KRAD associates each of these input types with an object implementing the org.kuali.rice.kns.uif.control.Control interface.

h4. TextControl

An org.kuali.rice.kns.uif.control.TextControl represents a simple HTML text field, mapping to an <input type="text" /> tag.  Simple, indeed, but widely used as well - easily the most frequently used of all Controls.  [JAMES, CONTINUE]

||Property Name||Type||Description||
|size|int|The size of the displayed TextControl|
|datePicker|org.kuali.rice.kns.uif.widget.DatePicker|A DatePicker associated with this text control, assisting the user to choose a date and then formatting it correctly if the text represents a date.|

h4. TextAreaControl

This Control represents a text area on the page.  It maps to the HTML <textarea> tag.

h4. FileControl

A Control which uploads files.  It maps to the HTML <input type="file" /> tag.

h4. HiddenControl

This Control represents an attribute which stores its value in HTML, so that its state can be maintained, but which does not render in any meaningful way that an application user can see.  It maps to the <input type="hidden" />

h4. Checkbox Control

The org.kuali.rice.kns.uif.control.CheckboxControl is KRAD's favored way of getting input for boolean values.  It maps to an <input type="checkbox" /> HTML tag but it also adds a hidden variable to tell the input that the checkbox was rendered.  If the hidden field is present in the request parameters but not the checkbox itself, then KRAD knows to set the value on the business object as false.  On lookup fields, CheckboxControls convert into groups of radio buttons with values "Yes", "No", and "All".

h4. MultiValue Controls

Certain controls let the user choose among multiple values.  All of these controls extend org.kuali.rice.kns.uif.control.MultiValueControlBase.  To make these controls work, KRAD needs to know what the set of choice values are and MultiValueControlBase supports those through the property options which takes a java.util.List of venerable org.kuali.rice.core.util.KeyLabelPair objects.  Each KeyLabelPair maps a code value to a the display label which is what the user sees for the control (these two values could be the same but often times, the label is a more user-friendly representation of the key code).  [JAMES: HOW TO SET UP OPTIONS FINDERS IN KRAD?]

h5. SelectControl

A SelectControl presents a list of clickable elements to the user, where each clickable element shows a label.  These controls map to the HTML <select> tag.  By default, only one value in a SelectControl can be chosen, but by setting the mulitple property to true, multiple rows can be chosen.

||Property Name||Type||Description||
|options|java.util.List<org.kuali.rice.core.util.KeyLabelPair>|The List of options that will be displayed in this Select Control.|
|multiple|boolean|If true, allows any number of KeyLabelPairs in the Select Control to be chosen by ctrl- or cmd-clicking multiple values.  If false, only allows one value to be chosen.|
|size|int|If the SelectControl is set to select multiple values, the number of rows of values that should be shown on the screen without scrolling.|

h5. RadioGroupControl

A RadioGroupControl represents several <input type="radio" /> HTML tags.  Unlike the SelectControl, which displays all of its values as one visual element, the RadioGroupControl represents each label as a value sitting by a friendly button which can be pushed.  Also in contrast to the SelectControl, RadioGroupControls only ever let one value at a time be chosen.  They're fairly rare in traditional KNS applications, being used only where there's an extremely limited number of choices, one of which must be unequivocally chosen.

||Property Name||Type||Description||
|options|java.util.List<org.kuali.rice.core.util.KeyLabelPair>|The List of options that will be displayed in this Select Control.|

h3. Widgets

A Widget is a grouping of several related rendering items which provide a single functionality.  Take, for instance, the quickfinder: the useful magnifying glass icon that takes a user to an appropriate lookup for a field.  Here, we have an image and a created link: together, that functionality forms a widget.  Widgets are something like controls but don't map directly to HTML inputs--though several widgets are used in conjunction with Controls to make those controls more powerful.

h4. BreadCrumbs

Bread crumbs remember the context of a page and provide a set of links that can take the user back to a "root" page.

Let's say, for instance, that a user goes from the portal to a lookup.  The current context is the lookup and the root is the portal, so the breadcrumbs will provide a link back to the portal.

On the lookup, the user clicks a quick finder to lookup a secondary business object.  Let's say that business object is a Kuali Enterprise Workflow document type.  On this lookup, there are links back to the portal and the previous lookup.

As the user gets deeper into the nest of functionality, the breadcrumbs provide links to get the user back to all previous steps in the process.  This makes it much easier for users to know where they are in the application and to get back to previous steps in the process--thus allowing users to escape from confusing or mistaken steps in a process.

h4. DatePicker

This widget is often used in conjunction with a Text Control if the data binds to a date.  It basically adds an icon that will shows a pop-up calendar on click, thus making it easier for the user to enter date related data (and guaranteeing that if the user clicks the calendar, the date will be in the format that the Kuali application accepts).

h4. Help

This is an icon which pops up a window with explanatory text to help the user.  The Help widget is context aware so it knows which kind of help to display: whether it is help for an entire document (that is, the icon is placed next to a document title) or help for a single field (in which case the icon is rendered next to the field).  The source of the help is also configurable: whether it comes from text in a parameter or from a static url.  Finally, Help can be extended so that as different help contexts exist in client applications, they can be added.

h4. Inquiry

This widget represents a direct inquiry icon: an icon which, when pressed, opens an inquiry page based on values in Controls (rather than the traditional inquiry which is a link in lookup results).

h4. QuickFinder

The traditional Kuali magnifying glass icon has been around since the first version of Kuali Financial Systems: it's as venerable as Kuali functionality gets.  Rendered next to a field, it opens a lookup so that users can choose an appropriate value for the field.

h3. Fields

Controls are simple because, for the most part, they map directly to HTML input types.  Widgets make a lot of sense as well, since each Widget represents a single set of functionality.  Fields, though, are not at all as simple to classify.  Some--such as BlankField--are as simple and inert as elements on an HTML page get.  Some, such as AttributeField or GroupField are wildly complex, rendering a combination of Containers, Controls, and other Components.  Fields are basically the grab bag of other visual elements in KRAD.

What all Fields have in common is that they implement the org.kuali.rice.kns.uif.field.Field interface, an interface that allows pretty much any child to have an associated label.  (Of course, there's a LabelField which itself represents a Label).

Let's take a tour of the Fields that KRAD offers.

h4. ActionField

An ActionField represents an element that gives the user the ability to perform an action.  Many actions kick off a web request/response cycle.  For instance, the submit button of a Form would be represented as an ActionField.  A link in a menu would be represented as an ActionField.  Even rich scripts could be represented as an ActionField as well--some of which do Ajax calls to the server to pull more data into a page, and some of which just perform some client side JavaScript call.  No matter what, an ActionField represents the user telling the application to get something done.

An ActionField must have either a methodToCall or navigateToPageId set.  Setting the methodToCall will end up calling a method on a controller, and the great majority of ActionFields will populate this property.  navigateToPageId would be used for ActionFields which move the user around in a multi-page document, like the Kuali Coeus Proposal.

The actionParameters property is a map of parameters which will be passed along as part of the HTTP request.  The actionLabel property represents the text which will be displayed on the button or link.  Finally, ActionField has a boolean property, clientSideCall, which will be set to true if the ActionField represents an action which is handled by Javascript.

h4. AttributeField

An AttributeField represents an Attribute on a page.  This means that the Field will display a Control--for user input into the Attribute--as well as error messages associated with the Field, instructions, watermarks: basically everything the Attribute needs to display correctly on the page. This is easily the most functional of all Fields, so let's look at what all it does in detail.

[JAMES: MOST IMPORTANT FIELD.  DESCRIBE MORE]
- tie to data dictionary

An AttributeField correlates directly to an AttributeDefinition set on either a BusinessObject or a Document.  Every AttributeDefinition represents a single property on its related object.  The AttributeDefinition then defines a great deal of information about that property: what kind of Control it should be associated with, the maximum length of the input, labels, validation patterns, and how to format the property--so that if the property represents non-String data, it can be converted into the data type of the property.

The vast majority of properties which populate the pages of a KRAD application will be represented by DataDictionary AttributeDefinitions.  KRAD's support of translating AttributeDefinitions to all of the equivalent rendered HTML on a page through the AttributeField is very powerful.

There are several encapsulated properties at the heart of the AttributeField.  Let's start with the two basic: formattedValue and control.  The formattedValue is the data held by the attribute--either to be rendered to the screen or to be populated by the control.  The control, of course, is the associated Control Component, which will allow the user to input data into the formattedValue.

Of course, the DataDictionary AttributeDefinition defines a lot of text about the attribute: the label and summary texts as well as a possible default value.  The AttributeField holds all of these as well.  The AttributeField also holds the most important validation defined in AttributeDefinition--that of maxLength.  (It's the most important because if values exceed maxLength, they will likely cause exceptions when inserted into the database--that goes for data of a number of data types.)

AttributeField also holds errors associated with the attribute.  If the Control associated with this attribute put in data that failed validation, or if a special warning message needs to be associated with the attribute, AttributeField encapsulates that as well, by holding these errors in an ErrorsField.  There's also an errorPlacement property which tells KRAD what aspect of the rendered field to render errors to.  [JERRY: POSSIBLE VALUES? "LEFT", "RIGHT", "ABOVE", etc?]

The AttributeField also holds the Formatter responsible for taking Strings in the HTTP request and translating them into different data types.  If the attribute's control is a MultiValueControl with an OptionsFinder, the AttributeField also holds that.

Finally, the AttributeField has an org.kuali.rice.kns.uif.BindingInfo object which holds information on how the attribute should be rendered to HTTP responses and from HTTP requests.  Data bindings are discussed [below#data_bindings] but the short of it is that AttributeField remembers its path in the complex tree of the document and can use that information to get data back and forth to the page--so that developers don't need to worry about those details.

That's a lot for AttributeField to hold.  What does AttributeField render?  First, it renders a Label for the attribute, often by creating a LabelField which then can be rendered beside or above the Control as the parent View demands.  It also renders summary information for the AttributeField.  Obviously, the AttributeField will render a Control for the attribute--assuming the attribute hasn't been rendered hidden or read only by some other participant in the rendering process, such as a KIM permission.  When rendering a Control, the AttributeField will render a classic Kuali quick finder magnifying glass icon for attributes which need separate lookups, and AttributeField will render any specified constraint text for attributes which demand a specific input format.  AttributeField will also render help for the attribute if applicable.

Certainly, all of this makes AttributeField the most powerful of Fields, but, importantly, it has one concern: the proper rendering if an attribute to a View.  KRAD gets a lot of power by putting metadata about attributes on documents and business objects into the Data Dictionary.  AttributeField concentrates that power by offering a single point which coordinates the full rendering of the attribute.

Of course, there's other fields yet to understand.  Let's continue our tour.

h4. BlankField

A BlankField represents empty visual space on a page.  [JERRY: TRUE THAT?]

h4. ErrorsField

This Field represents error messages, warning messages, and info messages which should be rendered in a Container.  Each set of messages--error, warning, and info--can have a unique title set as well as a unique CSS class (such that errors can show up bolded, say, and warnings can be displayed in italics).  A keyMatch String can also be passed in to the definition, which will be matched against the properties of Controls displayed within the parent Container.  That way, only messages relevant to children fields will be rendered in the ErrorsField.

h4. GroupField

A GroupField encapsulates a Group for display without headers and footers.  [JERRY: USE CASE?]  It has one property, group, which should be injected with the Group to display.

h4. HeaderField

A HeaderField will display Header text on a page.  Headers often create a sense of visual hierarchy to a page and therefore are very important structural markers.  HeaderFields have passed in a headerLevel: a number between 1 and 6 representing the importance of the Header on the page (1 being the most important, 6 being the least) and headerText, which is the text the header will display.  [JERRY: IT WOULD BE EVER SO NICE IF YOU COULD PASS IN A MESSAGE KEY INSTEAD OF JUST TEXT.  THIS IS TRUE OF ANYTHING WHICH TAKES IN TEXT]

h4. ImageField

The ImageField renders an image.

h4. LabelField

A LabelField represents a Label.  Labels are most often associated with controls.  A text control with no explanatory text to say what kind of data is expected to be filled in isn't very useful; LabelFields give users the general gist of the Control.

In a great majority of cases, AttributeField will create a LabelField when it displays.  There are rare times when Controls are created outside of attribute definitions, however, and in those cases, a LabelField will have be configured manually.

A LabelField has a property for labelText.  There's also a property for labelForComponentId - the id of the Component which the Label relates to; setting this helps with accessibility issues for sight-disabled users.  There is a boolean property on whether to render a colon or not, renderColon, and finally an encapsulated MessageField, requiredMessageField, which should be populated if the Label represents a required Control.

h4. LinkField

A LinkField represents a Link on a page and is rendered with an HTML <a> tag.  It needs to have its hrefText set to the target of the link and linkLabel set to the text which will be rendered as the link.  There is also an optional target attribute which can be used to set where the linked content should open up; for instance, setting target to "_blank" will open the link into a new browser tab or window.

h4. MessageField

A messageField displays text on the rendered page within a span.  Its messageText property holds the text which it will display.  It also has a messageType property which helps uniquely identify all messages of this type on the screen.

h3. Data Bindings{anchor:data_bindings}

One of the major changes that KRAD will bring will be a move away from Apache Struts 1.2+ to Spring 3.0's Web MVC.  This means many things: changes to Controllers, some updates to Forms - though the KRAD team is working on scripts to make these changes as painless as possible.

A major concept invoked by WebMVC is that of data binding.  Data binding simply means that parameter names from a request will be mapped into the form.  Spring handles much of this automatically, by simply using the Form as the root of a property tree and then mapping nested, indexed, or even indexed and nested properties into the form.

Spring does need help on mapping parameters into classes it doesn't handle automatically - KualiDecimal, for instance.  In these cases, Java provides PropertyEditors which can convert Strings into complex objects.  There are a number of mechanisms that help Spring associate a PropertyEditor implementation with a complex object like KualiDecimal. [JERRY: WHAT IS THE RECOMMENDED PROPERTY EDITOR REGISTRATION MECHANISM?]

Creating a PropertyEditor is a straightforward process.  Java provides the java.beans.PropertyEditorSupport object which can be extended.  That class has two crucial methods to override: String getAsText(), which converts the contents of the object into text; and void setAsText(String text) which takes a String and converts it into the complex object.

The Spring documentation covers how it uses data bindings in much more detail [on the SpringSource website#http://static.springsource.org/spring/docs/2.0.x/reference/validation.html]  Spring has a heavy reliance on this mechanism throughout its source code beyond populating form data.  But it does give Spring a very standard way to populate the form from the request.

As KRAD renders a page with form data, it will properly generate the data binding path that will properly populate the form when the page is submitted.  It will create indexed property names for values within collections and it will create nested names for all the attributes on a page...meaning that for the most part, developers will never concern themselves with data binding--KRAD will just make it happen in the background.

New Components which want to participate in the DataBinding process should implement the org.kuali.rice.kns.uif.DataBinding interface.  This interface has one method, getBindingInfo(), which returns a populated instance of org.kuali.rice.kns.uif.BindingInfo.  BindingInfo encapsulates a number of properties:
* bindingName - this is the name of the property to bind to, either within the form or the model.
* modelName - if this property is supposed to bind to a model, what's the path of the model to the form?
* bindByNamePrefix - this is a prefix generated by KRAD, typically when rendering a Collection.  Basically, it generates the proper name and index (for example, "collectionItem[0]") and holds that for the sake of the current binding.
* bindToModel - when true, this means that the given property should be bound to some root model.  The classic root model of a KRAD application is, of course, a document - so properties related to documents should have bindToModel set to true.
* bindToForm - when true, this makes sure that the given property is bound to the Struts MVC form itself.

[JERRY: WHAT HAPPENS IF BINDTOMODEL AND BINDTOFORM ARE BOTH FALSE]

The most important Component to implement this interface is the AttributeField.  AttributeFields display and read data on business objects and documents, so naturally they participate in the data binding process.
[JERRY, WHY DON'T THE CONTROLS IMPLEMENT THIS?]

h3. Component Architecture

Now that we've explored each component type in detail, let's see what they share and what all KRAD visual elements have in common.

||Property|Type|Explanation||
|id|java.lang.String|The Component's unique name within the rendered HTML.|
|componentTypeName|java.lang.String|The type name of the Component: "Text" for the Text Control, for instance, or "Quickfinder" for the Quickfinder widget|
|template|java.lang.String|As discussed in [Tiles as Templates#tiles_as_templates], the path to the JSP representing the tile for this component|
|componentInitializers|List<org.kuali.rice.kns.uif.initializer.ComponentIntializer>|A list of all ComponentInitializers that should be run on the component upon initialization.  Covered in more detail in [Component Intializers#component_initializers]|
|name|java.lang.String|[JERRY: HOW DOES THIS DIFFER FROM ID?  This is the bean name and the other is the HTML id]|
|render|boolean|Determines if this component should be rendered.|
|hidden|boolean|[???]|
|readOnly|boolean|Determines if the Component should be rendered as readOnly (in the case of Controls, this means just data is shown-there is no ability to input a different value)|
|required|java.lang.Booolean|Determines whether the Component is required to be filled in.  Again, typically used in conjunction with Controls.|
|style|java.lang.String|The style attributes of the Component.  The value of this will be rendered in a "style" attribute on the Component.|
|styleClass|java.lang.String|The name of the CSS class which this component will render in.|
|width|java.lang.String|The width of the Component, in any measurement that HTML supports|
|align|java.lang.String|The horizontal alignment of the Component within its Container. [JERRY: DOES THIS USE CSS OR HTML ALIGN? I DOCUMENTED CSS VALUES] The allowed values are "left" (which is the default for Western character sets); "right"; "center"; and "justified" which attempts left and right alignment on lines.|
|valign|java.lang.String|The vertical alignment of the Component within its Container. The allowed values are "baseline" (which aligns the baseline of the characters of this Component to align with the baseline of the parent - this is the default); "sub" (making the text align as subscript); "super" (making the text align as superscript); "top" (which aligns the text of the Component with the top of the tallest element--text or non-text--on the rest of the line); "text-top" (which aligns the text of the Component with the top of the tallest text element on the rest of the line); "middle"; "bottom"; or "text-bottom" (which, like "text-top" aligns with the bottom of only text elements on the rest of the line).|
|colSpan|int|The number of table columns in the parent Container that this Component will span.|
|rowSpan|int|The number of table rows in the parent Container that this Component will span.|
|decorators|java.util.Map<java.lang.String,org.kuali.rice.kns.uif.decorator.ComponentDecorator>|A Map which associates names of child Components with implementations of ComponentDecorators[JERRY: TRUE THAT?], as discussed in the section on [Component Decorators#component_decorators]|

h4. Tiles as Templates{anchor:tiles_as_templates}

In the Spring configuration for every Component, a template is injected.  This is a path to a JSP page which is actually responsible for rendering the Component.  Each KRAD JSP page utilizes Apache Tiles to do the rendering.  This means that variables are passed around from tile to tile in a standard fashion, using the tiles:putAttribute tag for writing and the tiles:useAttribute tag for reading.  Because variable passing is standardized, Tiles can nest JSP pages within each other in a much more flexible manner than standard JSP tags.

This is incredibly important because the injection of a Tile template path into the Spring configuration for a Component means that rendering of all Components is entirely customizable.  If, for instance, an application developer wanted to make a change to every single text field rendered through the application - a change which could not be achieved through the already incredible flexibility of CSS stylesheets - then the developer would simply override the TextControl bean and set the template property to point to a different JSP template.  KRAD would still pass all the variables it normally would to the new Tile.  Of course, a the switching out of a major Control likely won't happen.  But adding a new Component - a Widget that makes some innovative use of the jQuery UI library, say - is incredibly easy in this scheme.  Simply create a Java bean which extends the WidgetBean base class and then create a Tile that renders the new Component and the new Component is available for use in the application.

Furthermore, since each Component bean handles its own rendering Tile template, gone will be the generic KNS tags - like kul:rowDisplay and kul:htmlControlAttribute - which depended on complex logic within the tag itself to decide rendering and which were nearly impossible to customize.  It's a huge step forward for application developers to be able to customize the user interface of their application.

h4. Component Initializers{anchor: component_initializers}

It's often useful for Components, upon initialization, to have some access to the rest of the Component tree.  For instance, when a Group is initialized, it may want to cull out any Label Fields within it so that it can decide how to render them: above Controls or beside Controls.  This culling is done via a ComponentInitializer.  Therefore, any Component can have associated with it a List of org.kuali.rice.kns.uif.initializer.ComponentIntializer implementations.

Each ComponentIntializer has two methods which must be given implementations.  getSupportedComponents returns the Class of the Components which support the initializer.  performInitialization is passed in the parent view and the Component that this initializer is working on, and that is where the manipulation of the Component tree is carried out.

h4. Component Decorators{anchor: component_decorators}

Components are powerful, it's true, but putting too much power into a single Component often violates the principle of separation of concerns.  Classes which implement org.kuali.rice.kns.uif.decorator.ComponentDecorator provide a little extra functionality to another Component, without making the code for that wrapped Component more complex.

For instance, many Groups represent tabs which can be opened or closed.  A Group was written simply to be a simple Container of Components--making all of them understand collapsing behavior seems a bit overkill, especially considering how general Groups are.  Therefore, a ComponentDecorator--org.kuali.rice.kns.uif.decorator.PanelGroupDecorator--was created to add collapsing behavior to Groups.  Parent Containers which want to apply collapsing behavior to child Groups will add the name of the Group and the ComponentDecorator to a map called "componentDecorators" and the collapsing behavior will be added during rendering.